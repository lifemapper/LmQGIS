<!DOCTYPE html>
<meta charset="utf-8">
<style>


path {
  stroke: white;
  stroke-width: 0.25px;
  fill: grey;
}

.myselection {
	  stroke: yellow;
	  stroke-width: 1.41px;
	  fill: none;
	}

  // dynamically change this
  svg {
      cursor: crosshair;
    }
  
  
 

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v0.min.js"></script>

<script>
var width = 960,
    height = 500;

var projection = d3.geo.mercator()
    .center([-85, 0 ]) //[-85, 0 ]
    .scale(300) // 300
    .rotate([-180,0]);

function getMinMaxOf2DIndex(arr, idx) {
    return {
        min: Math.min.apply(null, arr.map(function (e) { return e[idx]})),
        max: Math.max.apply(null, arr.map(function (e) { return e[idx]}))
    }
}; 


function getScaled(){
	
    translate = projection.translate();
    
    //console.log(zoom.scale())
    // this won't work,needs an input coord
    var x = translate[0]/zoom.scale();
    var y = translate[1]/zoom.scale();
    x+=width/zoom.scale();
    y+=height/zoom.scale();
};

line = d3.svg.line()
    

drag = d3.behavior.drag()
.on("dragstart", function() {
  //console.log("dragstart outside func")
  coords = [];
  svg = d3.select(this);

  // If a selection line already exists,
  // remove it.
  //svg.select(".selection").remove();

  // Add a new selection line.
  //svg.append("path").attr({"class": "selection"});
  svg.append("svg:path")
  .attr({"class": "myselection"})
  .attr('stroke', 'red') // taken over by stylesheet
  .attr('stroke-width', '1px') // taken over by stylesheet
  .attr('fill', 'none');
})


.on("drag", function() {
    // Store the mouse's current position
	//console.log("drag dfgfd func")
    coords.push(d3.mouse(this));

    svg = d3.select(this);

    // Change the path of the selection line
    // to represent the area where the mouse
    // has been dragged.
    svg.select(".myselection")
       
       .attr('stroke', 'red')  // taken over by stylesheet
       .attr('stroke-width', '1px') // taken over by stylesheet
       .attr('fill', 'none')
       .attr({d : line(coords)});
  
  })
  .on("dragend", function() {
    svg = d3.select(this);
   
     
   //console.log(coords)
    //console.log(coords[0][0]) // pixels are inverted
    //console.log(coords[3][0])
    
    /* try {  // this is experimental
    	//g.selectAll("circle").remove();  //works for the most part
    	 
    	 circle = g.selectAll("circle").data('')  // removes better
    	 	circle
 	  			.exit()
 	  				.remove();
    		
    } catch(err){ } */
    
    // store old proj obj
    
    //oldProj = projection;
    
    xPixValues = getMinMaxOf2DIndex(coords,0) // pixels
    yPixValues = getMinMaxOf2DIndex(coords,1)
    
    // this section is the magic bit, for fixing correct coords after zoom/pan
    t = projection.translate()   
 	s = projection.scale();
    
    tx = t[0] * zoom.scale() + zoom.translate()[0]
    ty = t[1] * zoom.scale() +zoom.translate()[1];
    projection.translate([tx, ty]).scale(s * zoom.scale());
    // end magic
    
    
    
    //projection.translate(zoom.translate()).scale(zoom.scale());
    
    
    minsMap = projection.invert([xPixValues.min,yPixValues.max]) // max in pixels in y direction is opposite 
    maxsMap = projection.invert([xPixValues.max,yPixValues.min])

    
    bboxSend = minsMap[0]+','+minsMap[1]+';'+maxsMap[0]+','+maxsMap[1]
    //console.log(bboxSend)
    
    pyDialogMap.searchByBBOX(bboxSend);
    
    projection.translate([t[0], t[1]]).scale(s);
    //projection = oldProjection;
    //console.log(coords[0])
    //console.log(projection.invert(coords[0]))  // takes a two element array
   
 // don't know if I need this, and it is leaving behind bits
    
  /*  svg.append("svg:path")
       //.attr("class", "terminator")
       .attr('stroke', 'red')
       .attr('stroke-width', '1px')
       .attr('fill', 'none')
       .attr({ d : line([coords[0], coords[coords.length-1]])});
   */    	   
     
     
  });

// end drag

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    //.call(drag);


var path = d3.geo.path()
    .projection(projection);

var g = svg.append("g");


// load and display the World
d3.json("/home/jcavner/PAMBrowser/world-110m2.json", function(error, topology) {
    
	g.selectAll("path")
    .data(topojson.object(topology, topology.objects.countries)
        .geometries)
  .enter()
    .append("path")
    .attr("d", path)
	
	loadRange("/home/jcavner/PAMBrowser/presence-data.csv");
});




function loadRange(csvPath) {
// load and display the ranges
//console.log("in range")
d3.csv(csvPath, function(error, data) {
	//console.log(csvPath)
	
	    
  
    circle = g.selectAll("circle").data(data);
       //.data(data)
    
    
      
	  circle
       .enter()
       .append("circle")
     
       
      /*t = projection.translate();
	  s = projection.scale();
	    
	  tx = t[0] * zoom.scale() + zoom.translate()[0]
	  ty = t[1] * zoom.scale() +zoom.translate()[1];
	  projection.translate([tx, ty]).scale(s * zoom.scale()); */
       
       
	  circle
	  	.exit()
	  		.remove();
	  
	  //try {projection.translate([tx, ty]).scale(s * zoom.scale());}
	  //catch(err){}
	  
	  
	  
      circle 
		.attr("cx", function(d) {
		        return projection([d.lon, d.lat])[0];
		})
		.attr("cy", function(d) {
		        return projection([d.lon, d.lat])[1];
		})
		.attr("r", 1)
		.style("fill", "Chartreuse") 
	
    /*g.selectAll("text")
       .data(data)
       .enter()
     .append("text") // append text
       .attr("x", function(d) {
               return projection([d.lon, d.lat])[0];
       })
       .attr("y", function(d) {
               return projection([d.lon, d.lat])[1];
       })
       .attr("dy", -7) // set y position of bottom of text
      .style("fill", "black") // fill the text with the colour black
      .attr("text-anchor", "middle") // set anchor y justification
      .text(function(d) {return '';}); // define the text to display */


});

};  //end loadRange 

//var t = projection.translate(),
// 	s = projection.scale();


// zoom and pan
var zoom = d3.behavior.zoom()
    
    .on("zoom",function() {
    	
    	t = projection.translate()   
     	s = projection.scale();
        
        //tx = t[0] //* zoom.scale() + zoom.translate()[0]
        //ty = t[1] //* zoom.scale() +zoom.translate()[1];
        //projection.scale(s * zoom.scale())
    	
        g.attr("transform","translate("+ 
            d3.event.translate.join(",")+")scale("+d3.event.scale+")"); //d3.event.scale // - orig
        g.selectAll("circle")
            .attr("d", path.projection(projection))
            .attr("r", 1)
		    .style("fill", "Chartreuse");
        	//.attr("d", path);
        g.selectAll("path")  
            .attr("d", path.projection(projection)); 
        	//.attr("d", path); 
        
                
  });


function drawPoly(){
	
	svg.on(".zoom", null);
	svg.call(drag);
	
}

function callZoom(){
	svg.select(".myselection").remove();
	svg.on(".drag", null);
	// should by defualt be in zoom ??
	svg.call(zoom);
}

//dynamically change this
svg.call(zoom)

</script>

</body>
</html>